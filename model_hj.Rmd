---
title: "G9_p2"
author: "Hongjin Ren"
date: "2022/3/10"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries,warning=FALSE}
library(tidyverse)
library(moderndive)
library(skimr)
library(kableExtra)
library(gridExtra)
library(broom)
library(olsrr)
library(gapminder)
library(sjPlot)
library(stats)
library(jtools)
library(MASS)
library(janitor)
library(ROCR)
library(ggplot2)
```

```{r,warning=FALSE}
coffee <- read_csv("https://raw.githubusercontent.com/brent-strong/DAS2022-Group-09/main/dataset9.csv")
```

- country_of_origin – Country where the coffee bean originates from.
- aroma – Aroma grade (ranging from 0-10)
- flavor – Flavor grade (ranging from 0-10)
- acidity – Acidity grade (ranging from 0-10)
- category_two_defects – Count of category 2 type defects in the batch of coffee beans tested.
- altitiude_mean_meters – Mean altitude of the growers farm (in metres)
- harvested – Year the batch was harvested
- Qualityclass – Quality score for the batch (Good - ≥ 82.5, Poor - <82.5). Note: 82.5
was selected as the cut off as this is the median score for all the batches tested.

```{r}
coffee %>%
  group_by(country_of_origin) %>%
  summarise(n=n(),Mean=round(mean(altitude_mean_meters,na.rm=T),digits=2), St.Dev=round(sd(altitude_mean_meters,na.rm=T),digits=2),
            Min=min(altitude_mean_meters,na.rm=T), Q1 = quantile(altitude_mean_meters,0.25,na.rm=T), Median=median(altitude_mean_meters,na.rm=T),
            Q3 = quantile(altitude_mean_meters,0.75,na.rm=T), Max=max(altitude_mean_meters,na.rm=T))

```




```{r}
co_Na <- na.omit(coffee)
```

```{r}
cor(co_Na[2:6])
```


```{r}
library(ggplot2)
library(GGally)
ggpairs(co_Na, columns=2:6,aes(color=class))
cor(coffee[2:6])
```


#factor the respond data
```{r}
co_Na$class[co_Na$Qualityclass == "Poor"] <- 0
co_Na$class[co_Na$Qualityclass == "Good"] <- 1
co_Na$class <- factor(co_Na$class,
                      levels = c(0,1),
                      labels = c("Poor","Good"))

```

```{r}
coffee %>% 
  tabyl(Qualityclass, country_of_origin) %>% 
  adorn_percentages() %>% 
  adorn_pct_formatting() %>% 
  adorn_ns()

```

```{r}
coffee %>% 
  tabyl(Qualityclass, harvested) %>% 
  adorn_percentages() %>% 
  adorn_pct_formatting() %>% 
  adorn_ns()

```



```{r}
ggplot(coffee, aes(x= harvested,  y = ..prop.., group=Qualityclass, fill=Qualityclass)) + 
    geom_bar(position="dodge", stat="count") +
    labs(y = "Proportion")

```


```{r}
skim(co_Na)
```


I think we need to transform the num:year to chr:year
```{r}
co_Na$harvested <- as.character(co_Na$harvested)
```



#-------------------------------build model

```{r,warning=FALSE}
model_glm <- glm(class ~ aroma + flavor + acidity, data = co_Na,family = binomial(link = "logit"))
summary(model_glm)

```


```{r}
model_test <- glm(class ~ aroma + flavor + acidity + country_of_origin + category_two_defects + altitude_mean_meters + harvested, data = co_Na,family = binomial(link = "logit"))
summary(model_test)
```

```{r}
model_test <- glm(class ~ aroma + flavor + acidity + country_of_origin + category_two_defects + altitude_mean_meters, data = co_Na,family = binomial(link = "logit"))
summary(model_test)
```


```{r}
model_year <- glm(class ~ harvested, data = co_Na,family = binomial(link = "logit"))
summary(model_year)
```


```{r}
model_country <- glm(class ~ country_of_origin, data = co_Na,family = binomial(link = "logit"))
summary(model_country)
```

```{r}
model_cn_ye <- glm(class ~ country_of_origin + harvested, data = co_Na,family = binomial(link = "logit"))
summary(model_cn_ye)
```



```{r}
stepAIC(model_test, direction = 'both')
```



#--------------------------------test model

```{r}

pre <- predict(model_country,type='response')

data <- data.frame(prob=pre,obs=co_Na$class)

data <- data[order(data$prob),]
n <- nrow(data)
tpr <- fpr <- rep(0,n)

for (i in 1:n) {
    threshold <- data$prob[i]
    tp <- sum(data$prob > threshold & data$obs == "Good")
    fp <- sum(data$prob > threshold & data$obs == "Poor")
    tn <- sum(data$prob < threshold & data$obs == "Poor")
    fn <- sum(data$prob < threshold & data$obs == "Good")
    tpr[i] <- tp/(tp+fn) # 真正率
    fpr[i] <- fp/(tn+fp) # 假正率
}
plot(fpr,tpr,type='l')
abline(a=0,b=1)

```

```{r}
pred <- prediction(pre,co_Na$class)
performance(pred,'auc')@y.values #AUC值
perf <- performance(pred,'fpr','tpr')
plot(perf)
```




